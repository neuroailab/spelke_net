<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description"
        content="Discovering and using Spelke segments">
  <meta name="keywords" content="Segmentation, Computer Vision">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Discovering and using Spelke segments</title>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-PYVRSFMDRL"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }

    gtag('js', new Date());

    gtag('config', 'G-PYVRSFMDRL');
  </script>

  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro"
        rel="stylesheet">

  <link rel="stylesheet" href="./static/css/bulma.min.css">
  <link rel="stylesheet" href="./static/css/bulma-carousel.min.css">
  <link rel="stylesheet" href="./static/css/bulma-slider.min.css">
  <link rel="stylesheet" href="./static/css/fontawesome.all.min.css">
  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  <link rel="stylesheet" href="./static/css/index.css">
  <link rel="icon" href="./static/images/website_logo.png">

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script defer src="./static/js/fontawesome.all.min.js"></script>
  <script src="./static/js/bulma-carousel.min.js"></script>
  <script src="./static/js/bulma-slider.min.js"></script>
  <script src="./static/js/index.js"></script>
</head>
<body>

<section class="hero">
  <div class="hero-body">
    <div class="container is-max-desktop">
      <div class="columns is-centered">
        <div class="column has-text-centered">
          <h1 class="title is-1 publication-title">Discovering and using Spelke segments</h1>

          <!-- Smaller font size applied here -->
          <div style="font-size: 0.85rem;">
            <div class="is-size-6 publication-authors">
              <div>
              <span class="author-block">
                <a href="https://rahulvenkk.github.io/" target="_blank" rel="noopener noreferrer">Rahul Venkatesh</a><sup>*1</sup>,
              <span class="author-block">
                <a href="https://klemenkotar.github.io/" target="_blank" rel="noopener noreferrer">Klemen Kotar</a><sup>*1</sup>,
              <span class="author-block">
                <a href="https://www.linkedin.com/in/lilian-chen-1975b81b1/" target="_blank" rel="noopener noreferrer">Lilian Naing Chen</a><sup>*1</sup>,
              <span class="author-block">
                <a href="https://www.linkedin.com/in/seungwoo-simon-kim/" target="_blank" rel="noopener noreferrer">Seungwoo Kim</a><sup>*1</sup>,
              <span class="author-block">
                <a href="https://www.linkedin.com/in/luca-wheeler-180818244/" target="_blank" rel="noopener noreferrer">Luca Thomas Wheeler</a><sup>*1</sup>,
              <span class="author-block">
                <a href="https://www.linkedin.com/in/jared-watrous/" target="_blank" rel="noopener noreferrer">Jared Watrous</a><sup>*1</sup>,
              </div>
              <div>
                <span class="author-block">
                <a href="https://www.linkedin.com/in/ashley-xu-a2588b1a9/" target="_blank" rel="noopener noreferrer">Ashley Xu</a><sup>*1</sup>,
                <span class="author-block">
                  <a href="https://www.linkedin.com/in/gia-ancone-58b545207/" target="_blank" rel="noopener noreferrer">Gia Ancone</a><sup>*1</sup>,
                <span class="author-block">
                  <a href="https://www.linkedin.com/in/wanhee-lee-31102820b/" target="_blank" rel="noopener noreferrer">Wanhee Lee</a><sup>*1</sup>,
                <span class="author-block">
                  <a href="https://www.linkedin.com/in/honglin-chen-52b13712a/" target="_blank" rel="noopener noreferrer">Honglin Chen</a><sup>*1</sup>,
                <span class="author-block">
                  <a href="https://www.linkedin.com/in/daniel-bear-b79480279/" target="_blank" rel="noopener noreferrer">Daniel Bear</a><sup>*3</sup>,
                <span class="author-block">
                  <a href="https://sstojanov.github.io/" target="_blank" rel="noopener noreferrer">Stefan Stojanov</a><sup>*1</sup>,
                <span class="author-block">
                  <a href="https://web.stanford.edu/~yamins/" target="_blank" rel="noopener noreferrer">Daniel Yamins</a><sup>*1</sup>,

              </div>
            </div>

            <div class="is-size-6 publication-authors" style="margin-top: 0.5em;">
              <span class="author-block"><sup>1</sup>Stanford University,</span>
              <span class="author-block"><sup>2</sup>OpenAI,</span>
              <span class="author-block"><sup>3</sup>Noetik Inc.</span>
            </div>

          <div class="column has-text-centered">
            <div class="publication-links">
              <!-- PDF Link. -->
              <span class="link-block">
                <a href="https://arxiv.org/pdf/2011.12948"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="fas fa-file-pdf"></i>
                  </span>
                  <span>Paper</span>
                </a>
              </span>
              <span class="link-block">
                <a href="https://arxiv.org/abs/2011.12948"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="ai ai-arxiv"></i>
                  </span>
                  <span>arXiv</span>
                </a>
              </span>
              <!-- Code Link. -->
              <span class="link-block">
                <a href="https://github.com/google/nerfies"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="fab fa-github"></i>
                  </span>
                  <span>Code</span>
                  </a>
              </span>
              <!-- Dataset Link. -->
              <span class="link-block">
                <a href="https://github.com/google/nerfies/releases/tag/0.1"
                   class="external-link button is-normal is-rounded is-dark">
                  <span class="icon">
                      <i class="far fa-images"></i>
                  </span>
                  <span>Data</span>
                  </a>
            </div>

          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<section class="hero teaser">
  <div class="container is-max-desktop">
    <div class="hero-body">
      <video id="teaser" controls autoplay muted loop playsinline>
        <source src="./static/videos/teaser_vid.mov"
                type="video/mp4">
      </video>
      <h2 class="subtitle 6 has-text-grey mt-4" style="font-style: italic; text-align:justify">
        <strong>Overview of SpelkeNet's Capabilities.</strong> 
        On the <strong>left</strong>, our model first predicts a probability of motion map, indicating regions likely to move if an external force is applied. 
        We sample a point from this map and apply a virtual poke, conditioning our model to complete a flow field that reveals which other pixels will move as a result of this poke.
        Finally, from the flow field we can naturally extract a group of pixels which move together-i.e. a Spelke segment.
        On the <strong>right</strong>, we illustrate how these discovered segments can enable more physically plausible object manipulation.
      </h2>
    </div>
  </div>
</section>

<section class="section" style="padding-top: 1rem;">

  <div class="container is-max-desktop">

    <!-- SEC 1: Defining Spelke Objects -->
    <div class="content">
      <h2 class="has-text-weight-bold is-size-5 mb-4">Are existing definitions of segmentation sufficient for physical reasonings tasks?</h2>

      <!-- Main body paragraph -->
      <div class="content has-text-justified mt-5 is-size-6">
        <p>
          An ongoing challenge in image segmentation is defining segments with arbitrary categories, 
          as existing segmentation datasets like <a href="https://cocodataset.org/#home" target="_blank" rel="noopener noreferrer">COCO</a> and <a href="https://ade20k.csail.mit.edu/" target="_blank" rel="noopener noreferrer">ADE20K</a> 
          rely on semantic labels (e.g. car, tree, sky) to define segments.
          However, reliance on semantic labels to define segments is problematic because these definitions often conflict with the physical structure of scenes
          and therefore has less utility for robotics tasks like object manipulation, which require an understanding of physical reasoning to understand which parts of a scene move together in the physical world.
        </p>
      </div>

    </div>


    <!-- SEC 1: Defining Spelke Objects -->
    <div class="content">
      <h2 class="has-text-weight-bold is-size-5 mb-4">To address this limitation, we define Spelke Objects, segments based on motion correlation </h2>

      <!-- Main body paragraph -->
      <div class="content has-text-justified mt-5 is-size-6">
        <p>
          To address this limitation in existing definitions, we take from developmental psychology the notion of <strong>Spelke objects</strong>—groupings of physical things that reliably move together when acted on by physical forces.
          Spelke objects are defined by category-agnostic causal motion relationships, which can better support tasks like manipulation and planning compared to semantic-based segmentation.
        </p>
      </div>

    </div>

    <!-- SEC 2: Benchmarking Spelke Segments -->
    <div class="content">
      <h2 class="has-text-weight-bold is-size-5 mb-4">Benchmarking Spelke segments</h2>

      <!-- Main body paragraph -->
      <div class="content has-text-justified mt-5 is-size-6">
        <p>
          To systematically evaluate segmentation algorithms against Spelke principles, we introduce <strong>SpelkeBench</strong>—a 500-image dataset that measures how well segments align with Spelke objects.
          We curate the dataset from two complementary sources: <a href="http://luqi.info/entityv2.github.io/" target="_blank" rel="noopener noreferrer">EntitySeg</a>, featuring high-resolution internet imagery with dense segmentation annotations, and <a href="https://robotics-transformer-x.github.io/" target="_blank" rel="noopener noreferrer">Open X-Embodiment</a>, consisting of real-world egocentric robot interactions. 
          This contrast enables evaluation across both unconstrained natural image domains and physically grounded robotics environments.
        </p>
      </div>

      <!-- Image with caption -->
      <figure class="image is-inline-block has-text-centered">
        <img src="./static/images/benchmark_comparison.png"
             class="interpolation-image"
             alt="Comparison between datasets."  />
        <figcaption class="is-size-6 has-text-grey mt-2" style="font-style: italic; text-align:justify">
          Existing segmentation annotation methods are typically evaluated using benchmarks like SAM and EntitySeg, which frequently produce segments that intuitively do not represent units that would move together as a whole (e.g. camera subcomponents and bottle labels). 
          Since these models are evaluated using existing benchmarks, it becomes difficult to quantify their utility for tasks like robotic manipulation, which require understanding which parts of a scene move together in the physical world. 
          This demonstrates that current benchmarks fail to capture the notion of Spelke segments, limiting their utility for physical reasoning tasks. 
          Thus, we introduce SpelkeBench to benchmark model capability to produce segments aligned with Spelke objects.
        </figcaption>
      </figure>
    </div>

    <!-- SEC 3: Operationalizing Spelke Segments -->
    <div class="content">
      <h2 class="has-text-weight-bold is-size-5 mb-4">SpelkeNet: Operationalizing Spelke Segmentation</h2>

      <!-- Subsection 1: Local Random Access Sequence Modeling (LRAS) -->
      <div class="content has-text-justified mt-5 is-size-6">
        <p>
          We introduce <strong>SpelkeNet</strong>, our model that learns to complete flow fields and implicitly understands how objects move together in the physical world. 
          SpelkeNet is an instance of LRAS (Local Random Access Sequence Modeling), which provides an ideal foundation for this task because unlike diffusion models that require dense global conditioning, LRAS's autoregressive nature makes it simple to append localized interventions, enabling flexible composition of input sequences.

          Specifically, LRAS is a sequence model trained with next token prediction objective common in LLMs, where the final token sequence includes content tokens representing RGB or flow in arbitrary spatial order. 
          This sequential design leads to a flexible architecture which can accept a sequence composed of any subset of the combined sequence, making it particularly well-suited for sparse, targeted interventions.

          Building on this foundation, <strong>SpelkeNet</strong> capitalizes on LRAS's composable sequence design for Spelke object discovery. 
          Specifically, SpelkeNet applies sparse, localized interventions by simply appending a flow token representing the desired motion—i.e. a <strong>virtual poke</strong>—along with a corresponding pointer token indicating the poke location. 
          SpelkeNet then discovers Spelke objects by completing the remaining token sequence and extracting the completed flow field that reveals how the rest of the scene responds to this intervention.
        </p>
      </div>
      
      <figure class="image is-inline-block has-text-centered">
        <img src="./static/images/architecture.png"
            class="interpolation-image"
            alt="LRAS Architecture" />
        <figcaption class="is-size-6 has-text-grey mt-2" style="font-style: italic;">
          <strong>SpelkeNet Architecture.</strong> On the <strong>left</strong> we illustrate SpelkeNet—i.e. the LRAS framework applied to optical-flow completion. Each input image and its flow field are tokenized into spatially-indexed RGB and flow tokens. These token pairs are passed as an unordered sequence into the model, which outputs a categorical distribution <em>D</em>[<em>i</em>] over flow tokens for each spatial location <em>i</em>. In the <strong>right</strong> panel we show that sampling from these distributions yields a complete flow field in pixel space that we use for discovering co-moving entities/segments.
        </figcaption>
      </figure>

      <!-- Subsection 2: Motion Affordance Maps -->
      <div class="content has-text-justified mt-5 is-size-6">
        <h3 class="has-text-weight-bold is-size-6">Motion Affordance Maps</h3>
        <p>
          can just say obtain this by summing token dist for all tokens which represent non zero motion
        </p>
        <p>
          To discover Spelke objects, we must first identify which pixels correspond to candidate movable entities independent of camera motion within a scene in order to apply meaningful virtual pokes. 
          Motion affordance maps prove especially valuable in robotics applications for identifying high-motion regions that respond to interaction (e.g., cups or plates) and excluding
          low-motion regions (e.g., sky or ground) which do not typically do not move upon external forces.
          We refer to this notion as the <strong>probability of motion affordance map</strong>, denoted <em>p</em><sub>motion</sub>, which is a structure that we extract from SpelkeNet.
          To compute <em>p</em><sub>motion</sub>, we sum the predicted flow token distributions at each spatial location for all tokens which represent non-zero motion 
          to yield a 2D heatmap of regions likely to move under external forces.
        </p>
      </div>
      
      <!-- Carousel Container -->
      <div style="margin-top: 1rem; position: relative; max-width: 900px; margin-left: auto; margin-right: auto;">
        
        <!-- Carousel Images Container -->
        <div id="affordance-carousel" style="position: relative; overflow: hidden; border-radius: 8px; background: #f5f5f5;">
          <div id="carousel-images" style="display: flex; transition: transform 0.3s ease-in-out;">
            <img src="./static/images/affordancemap/1.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/affordancemap/2.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/affordancemap/3.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/affordancemap/4.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/affordancemap/5.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/affordancemap/6.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/affordancemap/7.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/affordancemap/8.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
          </div>
        </div>
        
        <!-- Navigation Buttons -->
        <button id="prev-btn" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 10;">‹</button>
        <button id="next-btn" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 10;">›</button>
        
        <!-- Image Counter -->
        <div id="image-counter" style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; z-index: 10;">1 / 8</div>
      </div>
      
      <!-- Caption -->
      <figcaption class="is-size-6 has-text-grey mt-2 has-text-centered" style="font-style: italic;">
        <strong>Motion Affordance Maps.</strong> Here we illustrate input images and their corresponding
        probability of motion heatmaps showing regions likely to exhibit motion under externally applied forces
      </figcaption>
      
      <script>
      (function() {
        let currentIndex = 0;
        const totalImages = 8;
        const imagesPerView = 3;
        const maxIndex = totalImages - imagesPerView; // 5 (positions 0-5)
        const carouselImages = document.getElementById('carousel-images');
        const imageCounter = document.getElementById('image-counter');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        
        function updateCarousel() {
          const translateX = -currentIndex * (100 / imagesPerView); // Move by 33.333%
          carouselImages.style.transform = `translateX(${translateX}%)`;
          
          const startImage = currentIndex + 1;
          const endImage = Math.min(currentIndex + imagesPerView, totalImages);
          imageCounter.textContent = `${startImage}-${endImage} / ${totalImages}`;
        }
        
        function nextImage() {
          if (currentIndex < maxIndex) {
            currentIndex++;
          } else {
            currentIndex = 0; // Loop back to start
          }
          updateCarousel();
        }
        
        function prevImage() {
          if (currentIndex > 0) {
            currentIndex--;
          } else {
            currentIndex = maxIndex; // Loop to end
          }
          updateCarousel();
        }
        
        nextBtn.addEventListener('click', nextImage);
        prevBtn.addEventListener('click', prevImage);
        
        // Optional: Auto-advance every 5 seconds
        // setInterval(nextImage, 5000);
        
        // Keyboard navigation
        document.addEventListener('keydown', function(e) {
          if (e.key === 'ArrowLeft') prevImage();
          if (e.key === 'ArrowRight') nextImage();
        });
        
        // Initialize
        updateCarousel();
      })();
      </script>

      <!-- Subsection 3: Expected Displacement Maps -->
      <div class="content has-text-justified mt-5 is-size-6">
        <h3 class="has-text-weight-bold is-size-6">Expected Displacement Maps</h3>
        <p>
          Another useful structure extracted from SpelkeNet is the <strong>expected displacement map</strong>, denoted <em>𝔼</em><sub>disp</sub>, which is an estimate of likely flow at each location conditioned on a virtual poke. 
          This proves especially valuable in robotics applications where understanding the effects of actions before physical contact is crucial. 
          This map provides guidance about how objects might move if interacted with, enabling robots to predict interaction outcomes without executing actions in the physical world. 
          To obtain <em>𝔼</em><sub>disp</sub>, we apply a virtual poke at a desired location to obtain a predicted distribution, which we then compute as a probability-weighted average over the flow vectors, giving us a dense 2D vector field over spatial locations.
        </p>
      </div>
      
      <!-- Expected Displacement Carousel Container -->
      <div style="margin-top: 1rem; position: relative; max-width: 900px; margin-left: auto; margin-right: auto;">
        
        <!-- Carousel Images Container -->
        <div id="displacement-carousel" style="position: relative; overflow: hidden; border-radius: 8px; background: #f5f5f5;">
          <div id="displacement-carousel-images" style="display: flex; transition: transform 0.3s ease-in-out;">
            <img src="./static/images/expecteddisplacement/1.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/expecteddisplacement/3.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/expecteddisplacement/4.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/expecteddisplacement/5.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
            <img src="./static/images/expecteddisplacement/2_.png" style="width: 33.333%; height: 600px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
          </div>
        </div>
        
        <!-- Navigation Buttons -->
        <button id="displacement-prev-btn" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 10;">‹</button>
        <button id="displacement-next-btn" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 10;">›</button>
        
        <!-- Image Counter -->
        <div id="displacement-image-counter" style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; z-index: 10;">1 / 5</div>
      </div>
      
      <!-- Caption -->
      <figcaption class="is-size-6 has-text-grey mt-2 has-text-centered" style="font-style: italic;">
        <strong>Expected Displacement Maps.</strong> Dense vector fields that predict how each pixel in a scene would move in response to a virtual poke applied at a specific location.
      </figcaption>
      
      <script>
      (function() {
        let displacementCurrentIndex = 0;
        const displacementTotalImages = 5;
        const displacementImagesPerView = 3;
        const displacementMaxIndex = displacementTotalImages - displacementImagesPerView; // 3 (positions 0-3)
        const displacementCarouselImages = document.getElementById('displacement-carousel-images');
        const displacementImageCounter = document.getElementById('displacement-image-counter');
        const displacementPrevBtn = document.getElementById('displacement-prev-btn');
        const displacementNextBtn = document.getElementById('displacement-next-btn');
        
        function updateDisplacementCarousel() {
          const translateX = -displacementCurrentIndex * (100 / displacementImagesPerView); // Move by 33.333%
          displacementCarouselImages.style.transform = `translateX(${translateX}%)`;
          
          const startImage = displacementCurrentIndex + 1;
          const endImage = Math.min(displacementCurrentIndex + displacementImagesPerView, displacementTotalImages);
          displacementImageCounter.textContent = `${startImage}-${endImage} / ${displacementTotalImages}`;
        }
        
        function nextDisplacementImage() {
          if (displacementCurrentIndex < displacementMaxIndex) {
            displacementCurrentIndex++;
          } else {
            displacementCurrentIndex = 0; // Loop back to start
          }
          updateDisplacementCarousel();
        }
        
        function prevDisplacementImage() {
          if (displacementCurrentIndex > 0) {
            displacementCurrentIndex--;
          } else {
            displacementCurrentIndex = displacementMaxIndex; // Loop to end
          }
          updateDisplacementCarousel();
        }
        
        displacementNextBtn.addEventListener('click', nextDisplacementImage);
        displacementPrevBtn.addEventListener('click', prevDisplacementImage);
        
        // Initialize
        updateDisplacementCarousel();
      })();
      </script>

      <!-- subsection 4: Spelke Object Discovery Algorithm -->
      <div class="content has-text-justified mt-5 is-size-6">
        <h3 class="has-text-weight-bold is-size-6">Statistical counterfactual probing for Spelke Object Discovery</h3>
        
        <div class="content has-text-justified mt-5 is-size-6">
          <p>
            Building on the previously discussed structures, we now combine <em>p</em><sub>motion</sub> and <em>𝔼</em><sub>disp</sub> to discover Spelke objects. 
            We first sample a location that is likely to move from <em>p</em><sub>motion</sub>. 
            Then, to discover Spelke objects we will identify regions that consistently move together under various virtual pokes applied at this location.
            For each poke direction, we compute <em>𝔼</em><sub>disp</sub>. 
            To find pixels that move in coordination with the poke, we average the dot product between each poke vector and the expected motion across all pokes. 
            This statistical aggregation reveals regions that consistently respond together regardless of poke direction—further implicitly aligning our discovered objects with the notion of Spelke objects which consistently move together. 
            Finally, Otsu's method on the averaged dot product yields our desired Spelke segment.  
          </p>
          <p>
            We evaluate the discovery procedure on SpelkeBench and report AR and IOU for various methods. From the table below, we see that SpelkeNet yields segments which best align with Spelke objects.
          </p>
        </div>
        
        <!-- Object Discovery Carousel Container -->
        <div style="margin-top: 1rem; position: relative; max-width: 900px; margin-left: auto; margin-right: auto;">
          
          <!-- Carousel Videos Container -->
          <div id="discovery-carousel" style="position: relative; overflow: hidden; border-radius: 8px; background: #f5f5f5;">
            <div id="discovery-carousel-videos" style="display: flex; transition: transform 0.3s ease-in-out;">
              <video autoplay muted loop playsinline style="width: 100%; height: 650px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
                <source src="./static/videos/obj_discovery/3.mov" type="video/mp4">
              </video>
              <video autoplay muted loop playsinline style="width: 100%; height: 650px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
                <source src="./static/videos/obj_discovery/2.mov" type="video/mp4">
              </video>
              <video autoplay muted loop playsinline style="width: 100%; height: 650px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
                <source src="./static/videos/obj_discovery/1.mov" type="video/mp4">
              </video>
            </div>
          </div>
          
          <!-- Navigation Buttons -->
          <button id="discovery-prev-btn" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 10;">‹</button>
          <button id="discovery-next-btn" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 10;">›</button>
          
          <!-- Image Counter -->
          <div id="discovery-video-counter" style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; z-index: 10;">1 / 3</div>
        </div>
        
        <!-- Caption -->
        <figcaption class="is-size-6 has-text-grey mt-2 has-text-centered" style="font-style: italic;">
          <strong>Spelke Object Discovery Algorithm.</strong>
          Multiple virtual pokes are applied at locations sampled from the <em>p</em><sub>motion</sub> map. As shown, this approach can discover multiple objects within a scene and produces more meaningful segments that align with Spelke objects as compared to the SAM segments.
        </figcaption>
        
        <script>
        (function() {
          let discoveryCurrentIndex = 0;
          const discoveryTotalVideos = 3;
          const discoveryVideosPerView = 1;
          const discoveryMaxIndex = discoveryTotalVideos - discoveryVideosPerView; // 2 (positions 0-2)
          const discoveryCarouselVideos = document.getElementById('discovery-carousel-videos');
          const discoveryVideoCounter = document.getElementById('discovery-video-counter');
          const discoveryPrevBtn = document.getElementById('discovery-prev-btn');
          const discoveryNextBtn = document.getElementById('discovery-next-btn');
          
          function updateDiscoveryCarousel() {
            const translateX = -discoveryCurrentIndex * (100 / discoveryVideosPerView); // Move by 100%
            discoveryCarouselVideos.style.transform = `translateX(${translateX}%)`;
            
            const currentVideo = discoveryCurrentIndex + 1;
            discoveryVideoCounter.textContent = `${currentVideo} / ${discoveryTotalVideos}`;
          }
          
          function nextDiscoveryVideo() {
            if (discoveryCurrentIndex < discoveryMaxIndex) {
              discoveryCurrentIndex++;
            } else {
              discoveryCurrentIndex = 0; // Loop back to start
            }
            updateDiscoveryCarousel();
          }
          
          function prevDiscoveryVideo() {
            if (discoveryCurrentIndex > 0) {
              discoveryCurrentIndex--;
            } else {
              discoveryCurrentIndex = discoveryMaxIndex; // Loop to end
            }
            updateDiscoveryCarousel();
          }
          
          discoveryNextBtn.addEventListener('click', nextDiscoveryVideo);
          discoveryPrevBtn.addEventListener('click', prevDiscoveryVideo);
          
          // Initialize
          updateDiscoveryCarousel();
        })();
        </script>
        
        <!-- Quantitative Results Table -->
        <div class="content has-text-justified mt-5 is-size-6">
          <table style="margin: 0 auto; border-collapse: collapse; text-align: center;">
            <thead>
              <tr style="border-bottom: 2px solid #000;">
                <th style="padding: 8px 12px;"></th>
                <th style="padding: 8px 12px;">SAM</th>
                <th style="padding: 8px 12px;">DINOv1-B/8</th>
                <th style="padding: 8px 12px;">DINOv2-L/14</th>
                <th style="padding: 8px 12px;">DINOv2-G/14</th>
                <th style="padding: 8px 12px;">CWM</th>
                <th style="padding: 8px 12px;">SpelkeNet</th>
              </tr>
            </thead>
            <tbody>
              <tr style="border-bottom: 1px solid #ddd;">
                <td style="padding: 8px 12px; text-align: left;">AR</td>
                <td style="padding: 8px 12px;">0.4816</td>
                <td style="padding: 8px 12px;">0.2708</td>
                <td style="padding: 8px 12px;">0.2524</td>
                <td style="padding: 8px 12px;">0.2254</td>
                <td style="padding: 8px 12px;">0.3271</td>
                <td style="padding: 8px 12px; font-weight: bold;">0.5411</td>
              </tr>
              <tr style="border-bottom: 2px solid #000;">
                <td style="padding: 8px 12px; text-align: left;">mIoU</td>
                <td style="padding: 8px 12px;">0.6225</td>
                <td style="padding: 8px 12px;">0.4990</td>
                <td style="padding: 8px 12px;">0.4931</td>
                <td style="padding: 8px 12px;">0.4553</td>
                <td style="padding: 8px 12px;">0.4807</td>
                <td style="padding: 8px 12px; font-weight: bold;">0.6811</td>
              </tr>
            </tbody>
            <thead>
          </table>
          <caption class="is-size-6 has-text-grey mt-4" style="margin-bottom: 1rem; font-style: italic;">
            <strong>Evaluation of point-prompted segmentation accuracy across models:</strong> We report Average Recall (AR) and mean Intersection over Union (mIoU) for various segmentation methods. SpelkeNet outperforms both self-supervised baselines (DINO, CWM) and the supervised SAM2 model
          </caption>
        </div>
      </div>
    </div>

    <!-- SEC 4: Using Spelke Segments for Physically Plausible Object Manipulation -->
    <div class="content">
      <h2 class="has-text-weight-bold is-size-5 mb-4">Using Spelke segments for Physically Plausible Object Manipulation</h2>
      
      <div class="content has-text-justified mt-5 is-size-6">
        <p>
          Segmentation plays a crucial role in object-centric scene editing, where users click on objects and provide edit prompts for 2D or 3D transformations. 
          The segmentation model creates edit masks from generated segments, making mask quality critical for realistic results. For physically plausible scene edits, masks must reflect genuinely movable entities rather than arbitrary visual boundaries.
          As such, Spelke segments prove particularly valuable for this application, yielding more realistic scene edits as we demonstrate in our experiments with SpelkeNet.
        </p>

        <p>
          To evaluate the utility of SpelkeNet segments for object manipulation, we replace SAM with SpelkeNet in the pipeline for existing object editing models.
          Specifically, we use <strong>3DEditBench</strong>, a benchmark containing 100 image pairs with associated ground truth point prompts and 3D scene edits (e.g. rotations, translations, inter-object occlusions). 
          From the table below, we show that for existing object manipulation methods, SpelkeNet segments improve performance signficiantly.
        </p>
      </div>
      
      <!-- Object Manipulation Carousel Container -->
      <div style="margin-top: 1rem; position: relative; max-width: 900px; margin-left: auto; margin-right: auto;">
        
        <!-- Carousel Videos Container -->
        <div id="manipulation-carousel" style="position: relative; overflow: hidden; border-radius: 8px; background: #f5f5f5;">
          <div id="manipulation-carousel-images" style="display: flex; transition: transform 0.3s ease-in-out;">
            <video autoplay muted loop playsinline style="width: 100%; height: 500px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
              <source src="./static/videos/objmanipulation/3_.mov" type="video/mp4">
            </video>
            <video autoplay muted loop playsinline style="width: 100%; height: 500px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
              <source src="./static/videos/objmanipulation/2_.mov" type="video/mp4">
            </video>
            <video autoplay muted loop playsinline style="width: 100%; height: 500px; object-fit: contain; flex-shrink: 0; background: white; padding: 0 5px;">
              <source src="./static/videos/objmanipulation/1_.mov" type="video/mp4">
            </video>
          </div>
        </div>
        
        <!-- Navigation Buttons -->
        <button id="manipulation-prev-btn" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 10;">‹</button>
        <button id="manipulation-next-btn" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; font-size: 18px; display: flex; align-items: center; justify-content: center; z-index: 10;">›</button>
        
        <!-- Image Counter -->
        <div id="manipulation-image-counter" style="position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 4px 8px; border-radius: 12px; font-size: 12px; z-index: 10;">1 / 3</div>
      </div>
      
      <!-- Caption -->
      <figcaption class="is-size-6 has-text-grey mt-2 has-text-centered" style="font-style: italic;">
        <strong>Comparison of SpelkeNet and SAM in Object Manipulation Pipeline.</strong> 
        From single-point segmentation prompt, the generated segment is used as input to  LRAS (state of the art image editing method) along with a 3D edit prompt.
        We show that SpelkeNet segments enable more physically plausible object editing as opposed to existing segmentation methods like SAM, which often often split up or combine objects in ways that are inconsistent with how they move.
      </figcaption>
      
      <script>
      (function() {
        let manipulationCurrentIndex = 0;
        const manipulationTotalImages = 3;
        const manipulationImagesPerView = 1;
        const manipulationMaxIndex = manipulationTotalImages - manipulationImagesPerView; // 2 (positions 0-2)
        const manipulationCarouselImages = document.getElementById('manipulation-carousel-images');
        const manipulationImageCounter = document.getElementById('manipulation-image-counter');
        const manipulationPrevBtn = document.getElementById('manipulation-prev-btn');
        const manipulationNextBtn = document.getElementById('manipulation-next-btn');
        
        function updateManipulationCarousel() {
          const translateX = -manipulationCurrentIndex * (100 / manipulationImagesPerView); // Move by 100%
          manipulationCarouselImages.style.transform = `translateX(${translateX}%)`;
          
          const currentImage = manipulationCurrentIndex + 1;
          manipulationImageCounter.textContent = `${currentImage} / ${manipulationTotalImages}`;
        }
        
        function nextManipulationImage() {
          if (manipulationCurrentIndex < manipulationMaxIndex) {
            manipulationCurrentIndex++;
          } else {
            manipulationCurrentIndex = 0; // Loop back to start
          }
          updateManipulationCarousel();
        }
        
        function prevManipulationImage() {
          if (manipulationCurrentIndex > 0) {
            manipulationCurrentIndex--;
          } else {
            manipulationCurrentIndex = manipulationMaxIndex; // Loop to end
          }
          updateManipulationCarousel();
        }
        
        manipulationNextBtn.addEventListener('click', nextManipulationImage);
        manipulationPrevBtn.addEventListener('click', prevManipulationImage);
        
        // Initialize
        updateManipulationCarousel();
      })();
      </script>

      <div class="content has-text-justified mt-5 is-size-6">
        <table style="margin: 0 auto; border-collapse: collapse; text-align: center;">
          <thead>
            <tr style="border-bottom: 2px solid #000;">
              <th style="padding: 8px 12px;">Method</th>
              <th style="padding: 8px 12px;">Segment</th>
              <th style="padding: 8px 12px;">MSE ↓</th>
              <th style="padding: 8px 12px;">PSNR ↑</th>
              <th style="padding: 8px 12px;">LPIPS ↓</th>
              <th style="padding: 8px 12px;">SSIM ↑</th>
              <th style="padding: 8px 12px;">EA ↑</th>
            </tr>
          </thead>
          <tbody>
            <tr style="border-bottom: 1px solid #ddd;">
              <td style="padding: 8px 12px; text-align: left;" rowspan="2">LRAS</td>
              <td style="padding: 8px 12px;">Spelke</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.009</td>
              <td style="padding: 8px 12px; font-weight: bold;">21.64</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.213</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.698</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.776</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
              <td style="padding: 8px 12px;">SAM</td>
              <td style="padding: 8px 12px;">0.013</td>
              <td style="padding: 8px 12px;">20.17</td>
              <td style="padding: 8px 12px;">0.255</td>
              <td style="padding: 8px 12px;">0.685</td>
              <td style="padding: 8px 12px;">0.633</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
              <td style="padding: 8px 12px; text-align: left;" rowspan="2">LightningDrag</td>
              <td style="padding: 8px 12px;">SpelkeNet</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.017</td>
              <td style="padding: 8px 12px; font-weight: bold;">19.16</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.195</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.672</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.679</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
              <td style="padding: 8px 12px;">SAM</td>
              <td style="padding: 8px 12px;">0.020</td>
              <td style="padding: 8px 12px;">18.18</td>
              <td style="padding: 8px 12px;">0.241</td>
              <td style="padding: 8px 12px;">0.658</td>
              <td style="padding: 8px 12px;">0.536</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
              <td style="padding: 8px 12px; text-align: left;" rowspan="2">Diffusion Handles</td>
              <td style="padding: 8px 12px;">SpelkeNet</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.024</td>
              <td style="padding: 8px 12px; font-weight: bold;">17.42</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.364</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.555</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.576</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
              <td style="padding: 8px 12px;">SAM</td>
              <td style="padding: 8px 12px;">0.031</td>
              <td style="padding: 8px 12px;">16.15</td>
              <td style="padding: 8px 12px;">0.419</td>
              <td style="padding: 8px 12px;">0.526</td>
              <td style="padding: 8px 12px;">0.495</td>
            </tr>
            <tr style="border-bottom: 1px solid #ddd;">
              <td style="padding: 8px 12px; text-align: left;" rowspan="2">DiffusionAsShader</td>
              <td style="padding: 8px 12px;">SpelkeNet</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.015</td>
              <td style="padding: 8px 12px; font-weight: bold;">19.29</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.194</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.707</td>
              <td style="padding: 8px 12px; font-weight: bold;">0.640</td>
            </tr>
            <tr style="border-bottom: 2px solid #000;">
              <td style="padding: 8px 12px;">SAM</td>
              <td style="padding: 8px 12px;">0.019</td>
              <td style="padding: 8px 12px;">18.20</td>
              <td style="padding: 8px 12px;">0.253</td>
              <td style="padding: 8px 12px;">0.682</td>
              <td style="padding: 8px 12px;">0.503</td>
            </tr>
          </tbody>
        </table>
        <caption class="is-size-6 has-text-grey mt-4" style="margin-bottom: 1rem; font-style: italic;">
          <strong>Evaluation of edit quality across segmentation methods and editing pipelines.</strong> We report results for edits generated using SAM versus SpelkeNet segments across four editing models. Lower ↓ is better, higher ↑ is better.
        </caption>
      </div>
    </div>

    <!-- SEC 5: Emergent Properties -->
    <div class="content">
      <h2 class="has-text-weight-bold is-size-5 mb-4">Emergent Properties of SpelkeNet</h2>
      
      <div class="content has-text-justified mt-5 is-size-6">
        <p>
          Beyond discovering co-moving entities, SpelkeNet exhibits emergent properties that demonstrate a deeper understanding of physical scene structure.
        </p>
      </div>

      <!-- Subsection 1: Material Property Understanding -->
      <div class="content has-text-justified mt-5 is-size-6">
        
        <figure class="image is-inline-block has-text-centered">
          <img src="./static/images/material.png" alt="Material Understanding" style="height: 500px; object-fit: contain; max-width: 100%;">
          <figcaption class="is-size-6 has-text-grey mt-2" style="font-style: italic;">
            <strong>Material Property Understanding.</strong> The generated probability of motion maps can be used to infer physical attributes such as rigidity or material type.
            Rigid objects like laptops and cardboard boxes tend to exhibit a
          uniform probability across the segment, while deformable objects such as cloth and plastic covers
          often show more localized motion responses near the poke point.
          </figcaption>
        </figure>
      </div>

      <!-- Subsection 2: Understanding Support Relationships -->
      <div class="content has-text-justified mt-5 is-size-6">
        <figure class="image is-inline-block has-text-centered">
          <img src="./static/images/support_relationships.png" alt="Support Relationships" style="height: 500px; object-fit: contain; max-width: 100%;">
          <figcaption class="is-size-6 has-text-grey mt-2" style="font-style: italic;">
            <strong>Support Relationships Understanding.</strong>. When applying a virtual poke to an object within a stack (e.g. the bottom book), the extracted Spelke segment includes both the directly contacted object and all the objects it physically supports, implying an understanding of support hierarchies within a scene.
          </figcaption>
        </figure>
      </div>
    </div>
  </div>
</section>


<section class="section" id="BibTeX">
  <div class="container is-max-desktop content">
    <h2 class="title">BibTeX</h2>
    <pre><code>@misc{venkatesh2025discoveringandusingsegments,
  title        = {Discovering and using Spelke segments}, 
  author       = {Rahul Venkatesh and Klemen Kotar and Lilian Naing Chen and Seoungwoo Kim and Luca Thomas Wheeler and Jared Watrous and Ashley Xu and Gia Ancone and Wanhee Lee and Honglin Chen and Daniel Bear and Stefan Stojanov and Daniel Yamins},
  year         = {2025},
  eprint       = {TODO},
  archivePrefix = {arXiv},
  primaryClass = {cs.CV},
  url          = {TODO}, 
}</code></pre>
  </div>
</section>


<footer class="footer">
  <div class="container">
    <div class="content has-text-centered">
      <a class="icon-link"
         href="./static/videos/nerfies_paper.pdf">
        <i class="fas fa-file-pdf"></i>
      </a>
      <a class="icon-link" href="https://github.com/keunhong" class="external-link" disabled>
        <i class="fab fa-github"></i>
      </a>
    </div>
    <div class="columns is-centered">
      <div class="column is-8">
        <div class="content">
          <p>
            This website is licensed under a <a rel="license"
                                                href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
            Commons Attribution-ShareAlike 4.0 International License</a>.
          </p>
          <p>
            This means you are free to borrow the <a
              href="https://github.com/nerfies/nerfies.github.io">source code</a> of this website,
            we just ask that you link back to this page in the footer.
            Please remember to remove the analytics code included in the header of the website which
            you do not want on your website.
          </p>
        </div>
      </div>
    </div>
  </div>
</footer>

</body>
</html>